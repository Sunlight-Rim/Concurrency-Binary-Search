# Концепция параллельного бинарного поиска
Представим, что мы ищем число X в некоем диапазоне. Используя метод бинарного поиска для нахождения X нам потребуется выполнить 5 операций сравнения, к напримеру. \
Однако наши компьютеры умеют обрабатывать данные параллельно, чем мы можем воспользоваться для оптимизации бинарного поиска X. \
На изображении ниже проиллюстрирована идея реализации этого, где сверху изображён поиск в виде дерева. Имея всего 4 потока мы можем разделить имеющийся диапазон, в котором находится X, на 4 части, и за один такт выполнить сравнение для них всех — тем самым "перепрыгивая" через несколько узлов дерева (а то есть операций сравнения). Как только мы узнаём, что X содержится в диапазоне AB, который является 1/4 всего диапазона, то мы снова делим AB на 4 части и назначаем сравнения всем потокам, и так далее, пока не найдём X. При таком методе вместо 5 сравнений мы делаем всего 2.

Кроме того, имея больше сведений об X, мы можем ещё сильней оптимизировать этот алгоритм с помощью потоков. В описанном выше варианте мы производили сравнения сверху вниз, "перепрыгивая" через узлы дерева на такой уровень, на котором кол-во узлов равно кол-ву имеющихся потоков. Однако эти значения не обязаны быть равными. Имея 4 потока, мы можем разделить исходный диапазон на 8 частей, затем исполнив все 8 сравнений за 2 такта. Это ориентированный-на-везучесть метод поиска, который однако становится полезен, если, к примеру, нам известно, что X вероятней имеет примерно небольшие значения, хотя и не хотим исключать огромные. На рисунке ниже мы выделили 2 треда для поиска X на самом нижнем уровне дерева — то есть среди конкретных значений.

![Illustration](Illustration.jpg)
