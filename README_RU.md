# Концепция параллельного бинарного поиска
Представьте, что вам требуется найти некоторое число X в заданном множестве значений (допустим, нужно проверить, содержится ли Х в таком множестве). Для этого вы могли бы воспользоваться бинарным поиском, выполняя деление множества пополам до тех пор, пока не удастся отыскать/удостовериться в отсутствии в нём Х. Однако, когда речь заходит о программировании такого метода, становится очевидно, что классический бинарный поиск является блокирующим непараллельным алгоритмом, что делает его достаточно неоптимальным как в I/O bound-, так и в CPU bound-задачах в современных условиях доступности многоядреных процессоров и многопоточности.

На изображении ниже проиллюстрирована идея реализации параллельного (concurrency) бинарного поиска на примере использования многопоточности. Для наглядности сверху поиск изображён в виде дерева. \
К примеру, для обхода некоторого множества классическим двоичным поиском для нахождения Х нам требуется 5 операций сравнения. В то же время, имея только 4 потока, мы можем разделить имеющийся диапазон с X на 4 части, и за один условный такт выполнить операции сравнения для них всех — тем самым "перепрыгивая" через несколько узлов дерева (= операций сравнения). Как только мы узнаем, что X содержится в диапазоне AB, который является 1/4 всего диапазона, то мы снова можем разделить AB на 4 части и назначить выполнение сравнений всем потокам, продолжая это до тех пор, пока не будет найден X. Таким образом, в данном примере вместо 5 сравнений мы производим всего 2.

Кроме того, если мы можем предположить, что Х будет вероятнее находиться в одном диапазоне значений, а не в другом, то, имея 4 потока, мы можем разделить исходный диапазон на 8 частей, затем исполнив все 8 сравнений за 2 такта. Также, если мы предполагаем что Х вероятней будет равным какому-то из значений определённого подмножества исходного множества, но и не хотим исключать проверку всех остальных значений этого множества, то мы можем выделить несколько потоков на проверку конкретных значений подмножества. Например, выделив 2 треда (на рисунке розовым) для поиска Х на самом нижнем уровне дерева — то есть среди конечных значений.

![Illustration](Illustration.jpg)
